# ITEM 69 - 예외는 진짜 예외상황에만 사용하라

사실, 예외를 엉뚱한 곳에서 사용하는 경우는 평범한 사람이라면 거의 없을 것 같다. 최적화를 위해서 JVM 의 동작을 임의로 추론한 후 실제 문법적 용도를 벗어나서 예외를 사용하는 경우가 있는데 이번 챕터에서는 이것에 대한 부작용을 이야기하고 있다. 예를 들면 for 문을 탈출하는 것을 예제로 들고 있다.<br>

일반 사람이라면 사용하지 않겠지만, 언젠가는 접하게 될 수 있다는 가정으로 이야기해주고 있다.<br>

<br>

## 핵심정리

예외는 예외 상황에서 쓸 의도로 설계되었다. 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 API 를 만들어서도 안된다.<br>

<br>

## 정상적인 예

아래의 코드가 있다고 해보자.

```java
for(Mountain m : range){
    m.climb();
}
```

`range` 라는 배열의 모든 `Mountain` 객체를 `climb()` 하는 코드다.<br>

<br>\위의 코드를 최적화하기 위해 JVM 의 동작을 추측해서 아래와 같이 수정했다고 해보자.

## 비정상 적인 예 - 예외를 특이한 용도로 사용했다.

```java
try{
    int i = 0;
    while(true)
        range[i++].climb();
}
catch(ArrayIndexOutOfBoundsException e){
    
}
```

코드만 봐서는 용도가 무엇인지는 확인하기 쉽지 않다. 다만, 코드를 파악하기 위해 자세히 보면 `range` 라는 배열의 마지막 `index` 를 넘어섰을 때 `ArrayIndexOutOfBoundsException` 예외를 내서 `while` 문을 탈출한다는 것을 간접적으로 추론해서 파악해내야 한다는 단점이 있다.<br>

<br>

**위 코드의 의도**<br>

위 코드가 예외를 써서 루프를 종료하려고 한 추론의 근거는 아래와 같다.<br>

>  JVM 은 배열에 접근할 때마다 배열의 경계에 넘어서는지 검사를 한다. 그런데 반복문에서 배열을 순회시키려고 보니, 반복문에서도 `index` 가 배열의 length 를 넘어서는지 검사를 해야 한다. 위 코드를 작성한 프로그래머는 `반복문 내에 배열 index 조건 검사식을 빼도 되겠다.` 하는 판단을 한다. <br>
>
> 그 결과로, while 문 내에 배열을 순회시키지만, index가 넘어섰는지는 예외가 발생했는지 여부로 판단하게끔 하는 코드를 만들어내게 되었다.<br>

<br>

**위 코드의 잘못된 점 3가지**<br>

실제로는 예외를 사용해 조금은 이상하게 작성한 코드가 일반적인 for/while 문을 사용할 때보다 느리다. 요소 100개 짜리 배열로 테스트해봐도 2배 정도 느리다.

- 예외는 예외 상황에서만 사용할 용도로 설계된 키워드다.
  - JVM 의 동작을 예측해서 예외를 만들어내는 코드를 구현했지만, 예외에 관련된 코드가 JVM 상으로 최적화될지는 장담하기 어렵다.
- 코드를 `try ~ catch` 블록안에 넣으면 JVM 이 적용할 수 있는 최적화가 제한된다.
- 배열을 순회하는 표준 순회 코드(첫번째 예제)는 위 코드를 작성한 프로그래머가 추측한 대로 중복되는 index 조건 검사를 실제로 중복해서 검사하지 않는다. JVM 이 알아서 최적화해 없애준다.

<br>

## 주요 내용 요약

예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다. 성능 목적으로 과하게 머리를 쓴 기법은 자제하라. 실제로 성능이 좋아지더라도 자바 플랫폼이 꾸준히 개선되고 있으니, 최적화로 얻은 잠시동안의 성능 우위가 자바 버전을 올리면서 유지되지 않을 가능성이 있다.<br>

API 설계에도 이 원칙이 적용된다. 잘 설계된 API 는 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.<br>

'상태 의존적' 메서드를 제공하게 되는 클래스는 '상태 검사'메서드도 함께 제공해야 한다. `Iterator`  인터페이스의 `next` 가 상태 의존적 메서드,  `hasNext` 가 상태 검사 메서드에 해당한다. `hasNext` 와 같은 상태 검사 메서드 덕분에 아래와 같은 for loop 관용구를 사용할 수 있다. (for-each 역시 내부적으로는 hasNext 를 사용한다)<br>

```java
for(Iterator<Foo> i = collecion.iterator(); i.hasNext();){
    Foo foo = i.next();
    // ...
}
```

<br>

## for loop 사용시 상태 검사 메서드 대신 사용할 수 있는 선택지 들

이 책에서 말하는 상태검사 메서드란 `hasNext()` 와 같은 함수를 의미한다. 일반적인 방식이라면 보통 for loop 내에서 iterator 방식이 사용하는 `hasNext()` 를 통한 상태검사를 수행하는 경우가 대부분일 것 같다.<br>

책에서는, iterator 객체가 아닌 일반객체를 순회할 경우에 대해서 상태검사 메서드 대신에 사용할 수 있는 대안들을 설명해주고 있다.

<br>

- 옵셔널 사용
  - 외부 동기화 없이 여러 스레드가 접근할 가능성이 있는 경우에 사용
  - 외부 요인으로 인해 상태가 변할 수 있는 경우에 사용
  - 옵셔널을 사용하는 이유
    - 함수의 특정 라인이 두개 이상의 라인으로 구성될 때, 서로 다른 스레드가 서로 다른 라인(문맥)을 읽고 있음으로 인해 데이터의 동기화가 제대로 이루어지지 않는 경우가 있다.
    - 이 경우 옵셔널을 사용하면 옵셔널이 리턴하는 객체를 통해 해당 문맥을 다른 스레드에 공유하지 않으면서 데이터의 동기화가 이루어질 수 있다. 
    - (이 부분은 개인적인 내피셜이어서 따로 다시 정리가 필요할것 같다. 멀티스레드/동시성 환경에서 함수형 코드를 사용하는 이유는 클로저와 같은 참조값을 이용해 동기화를 이루기 위해서다.)
- 옵셔널과 특정 값 둘중 하나를 선택하는 방식
  - 상태 의존적 메서드의 작업 일부를 중복 수행한다면, 옵셔널이나 특정 값을 선택하도록 구성한다
  - 특정 값을 선택하는 방식은 검사를 하지 않고 지나쳐도 발견하기가 어렵다는 단점이 있다.
- 상태 검사 메서드
  - 이 외의 모든 경우들에는 단순히 상태 검사 메서드를 사용하면 된다. 이렇게 하는 것이 가독성이 살짝 더 좋고, 잘못 하용했을 때 발견하기가 쉽다.

<br>