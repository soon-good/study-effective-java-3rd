# ITEM 10. equals 는 일반 규약을 지켜 재정의하라

보통 일반적인 Object의 equals() 메서드는, 인스턴스 자체의 hashCode를 비교한다. 이렇게 하면, 객체가 같은지 아닌지를 비교하게 된다. 만약 논리적인 값으로 동치성을 비교하고 싶다면, equals() 메서드를 오버라이딩하면 된다. 이번 장에서 다루는 주요 내용들을 요약해서 리스트업 해보면 아래와 같다.

- equals() 메서드를 재정의할 필요가 없는 경우들
- equals() 메서드를 재정의해야 하는 경우들 

<br>

equals() 관련 챕터인 이번 장은 너무 엄청나게 매우 길어서, 3일 ~ 4일은 걸려야 정리가 잘 될 것 같다. 잠시동안 해야하는 다른 일이 있어서 잠시 이펙티브 자바 정리를 미뤄두고 있었는데, 한번 정리할 때 하루에 30~1시간 정도는 투자를 해서 정리를 ㅐㅎ야 할것 같다. 어차피 야간 모니터링을 거의 매의 해야 되니... 멍때리기보다는 스터디를 ... 해야 겠다. 모니터링을 하다보면, 실제 공부를 할 수 있는 시간보다는 모니터링을 하는데에 시간을 많이 뺏기긴 하지만... 그래도 남는 시간 잘 활용해서 지금 상황을 벗어나야 할 것 같다!!!

<br>

## equals 를 재정의하지 않는 것이 오히려 더 나을 수 있는 경우들

equals 메서드는 재정의하기 쉬워보이지만, 곳곳에 함정이 도사리고 있어서 자칫하면 끔찍한 결과를 초래한다.<br>

Equals() 메서드를 잘못 정의해서 생기는 문제를 회피하는 방법은 아예 재정의하지 않는 것이다. 아래에 정의한 내용 들 중 하나에 해당된다면 equals() 메서드를 재정의 하지 않는 것이 최선이다.<br>

<br>

- 각 인스턴스가 본질적으로 고유하다.
- 인스턴스의 논리적 동치성(logical equality) 을 검사할 일이 없다.
- 상위클래스에서 재정의한 equals가 하위 클래스에도 딱 들어 맞는경우
- 클래스가 private 이거나 package-private 이고, equals 메서드를 호출할 일이 없다.

<br>

### 각 인스턴스가 본질적으로 고유하다

값을 표현하는게 아니라 동작하는 개체를 표현하는 클래스를 의미한다. 예를 들면 Thread 객체를 예로 들 수 있다. Object 의 equals() 는 이런 클래스에 맞게 구현되어 있다.<br>

### 인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없다.

논리적인 동치를 판단하는 것이 굳이 필요하다고 생각되지 않는다면, equals() 메서드는 오버라이딩하지 않는 것이 좋은 선택이다.<br>

java.util.regex.Pattern 클래스를 예로 들어보자. Pattern 클래스를 이용해 서로 다른 인스턴스 두개를 만들었다고 해보자. 이 때 두 인스턴스가 바인딩하고 있는 정규표현식이 서로 같은지를 검사하려고 할 수 있다. 보통 이런 경우 설계자 입장에서는 클라이언트 측에서 이런 기능이 필요하지 않다고 생각할 수 있고, 또는 애초에 필요하지 않다고 판단할 수 있다. 이렇게 필요없는 논리적 동치성에 대해서는 equals() 메서드를 재정의하지 않는 것이 낫다.<br>

### 상위 클래스에서 재정의한 equals 가 하위 클래스에도 딱 들어맞는다.

예를 들면,`AbstractSet`, `AbstractMap` 을 예로 들 수 있다. 대부분의 Set 구현체, Map 구현체들은 `AbstractSet`, `AbstractMap` 을 상속받아 정의되어 있다. 이 AbstractSet, AbstractMap 에서는 equals() 메서드를 구현하고 있는데, 이 것이 하위 클래스에도 적합하게 적용가능하다. 따라서 Set, Map 타입의 컬렉션을 구현해야 할 일 이 생긴다면 equals() 메서드를 오버라이딩을 하지 않아도 된다.<br>

### 클래스가 private 이거나 package-private 이고, equals 메서드를 호출할 일이 없다.

> Package-private 는 protected 키워드와 유사한 의미이다.

- 클래스가 private 이거나, package-private 일 경우,
- Equals 메서드를 호출할 일이 없을 경우

이런 경우 equals 메서드를 굳이 오버라이딩하지 않아도 된다.<br>

이런 경우 만약 위험을 피하기 위해 equals가 실수로라도 호출되는 것을 막으려 한다면 아래와 같이 코드를 구현해두자.

```java
@Override public boolean equals(Object o){
  throw new AssertionError(); // 호출 금지.
}
```

<br>

## equals() 를 재정의해야 하는 경우들

객체 식별성(object identity)가 아니라 논리적 동치성을 확인해야 할때 사용한다. 

> 여기서 객체 식별성(object identity)는 내가 만든 말이 아니고, 저자 조슈아 블로크 님이 사용하신 언어다. 

주로 값 클래스들이 여기에 해당한다. <br>

나머지 내용들은 내일 정리.
