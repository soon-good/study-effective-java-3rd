# ITEM 50. 적시에 방어적 복사본을 만들라

어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능해야 한다.<br>

주의를 기울이지 못하는 코드는, 내부를 수정하게 되는 경우가 생긴다.<br>

불변성을 지원하지 않는 낡은 API를 사용할 때 예제로 `Date` 클래스의 날짜를 위/변조 하는 경우를 예로 들고 있다. 그리고 이것을 방지하기 위해 적시에 방어적 복사본을 만드는 것에 대해서도 설명하고 있다.<br>

매개변수의 유효성 검사를 수행하기 전에 방어적 복사본을 만드는 작업을 수행하면 이런 위험에서 벗어날 수 있다. 이렇게 방어적 복사본을 만드는 것을 컴퓨터 보안 커뮤니티에서는 `검사시점/사용시점(time-of-check/time-of-use)` 공격 또는 `TOCTOU` 공격이라고 지칭한다.<br>

객체를 생성 후에 객체 내부에 참조변수가 있을 경우, 이 참조변수가 가리키는 메모리 상의 객체는 오픈된다. 이 경우 이 객체의 값을 수정하게 되는 가변성이 존재하게 될 가능성이 있다. 이런 이유로 가변성이 생길수도 있는 단적인 경우에 설명하고 있고, 적시에 방어적 복사본을 만들어서 대응하는 경우를 설명하고 있다.<br>

<br>

## 핵심정리

> 책에서 그대로 발췌

클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다. 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.<br>

<br>

## ex) 보안취약 사례 1) - Date 클래스를 외부에서 수정

클라이언트는 언제든 프로그래머가 작성한 클래스의 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고, 객체가 외부에서 수정되지 않게끔 방어적으로 프로그래밍해야 한다.<br>

실제로도 입력을 조작해서, 시스템의 구멍을 찾아내 보안을 뚫거나, 크래킹을 하려는 시도가 많다.<br>

아래의 `Date` 클래스를 사용하는 아래의 `Period` 클래스가 그 예제다. <br>

아래의 코드는 불변식처럼 보이고, 시작시간,종료시간에 대한 유효성 체크가 잘 된 것으로 보인다. 하지만, 그렇지 않다.

```java
public final class Period{
    private final Date start;
    private final Date end;
    
    /**
     * @param start 시작 시각
     * @param end 종료 시각
     * @throws IllegalArgumentException 시작 시각이 종료시각보다 늦을 때 발생한다.
     * @throws NullPointerException start 나 end 가 null 이면 발생한다.
    **/
    public Period(Date start, Date end){
        if(start.compareTo(end) > 0) 
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        
        this.start = start;
        this.end = end;
    }
    
    public Date start(){
        return start;
    }
    
    public Date end(){
        return end;
    }
    
    // 나머지 코드 중략
}
```

위의 코드는 불변식을 깨뜨릴 수 있다. 외부에서 내부의 상태값을 조작해서 의도하지 않은 결과를 만들어내서, 오동작을 일으키게 될 소지가 충분하다.<br>

아래의 코드를 보자.

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
end.setYear(78); // p의 내부를 수정했다!!!
```

<br>

## ex) 보완책 1 - `Instant`, `ZonedDateTime`, `LocalDateTime`

자바 8 이후부터는 위에서 언급한 `Date` 클래스를 사용하는 것으로 인한 문제를 쉽게 해결할 수 있다. `Date` 대신 불변인 `Instant` , `ZonedDateTime`, `LocalDateTime` 을 사용하면 된다. `Date` 는 오래된 API이고, 실제로 문제가 많은 자바 API 이기에 더 이상 사용하면 안된다.<br>

 `Date` 클래스, `Calendar` 클래스, `SimpleDateFormat` 클래스는 가급적 사용하지 않는 것이 좋다. 여기에 대한 참고자료는 아래와 같다. 추후 별도의 문서로 정리할 예정이다. 오늘 이 문서에서는 그냥 참고할만한 자료들만 정리!!!<br>

<br>

- [d2.naver.com - Java의 날짜와 시간 API](https://d2.naver.com/helloworld/645609)
- [당신이 `SimpleDateFormat` 을 쓰지 말아야 할 이유](https://techlog.myoa-universe.com/archives/786)
- [Java Time, Data 클래스의 문제점과 Java 8](https://hamait.tistory.com/205)

<br>

## ex) 보완책 2 - 복사본을 사용하도록 개선하기

위에서 작성한 `Period` 클래스의 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사(defensive copy) 해야 한다.

```java
public Period(Date start, Date end){
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());
    
    if(this.start.compareTo(this.end) > 0)
        throw new IllegalArgumentException(this.start + "가 " + this.end + " 보다 늦다.");
}
```

이렇게 새로 작성한 생성자를 사용하면 앞에서 사용한 객체의 내부를 객체 외부에서 수정하는 위/변조 코드는 더 이상 위협이 되지 않는다.<br>

위의 코드에서 매개변수의 유효성을 검사하기에 앞서 방어적 복사본을 만들고, 복사본으로 유효성을 검증한 것에 주목해야 한다.<br>

멀티스레딩 환경에서 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 위험한 순간에 다른 스레드가 원본객체를 수정할 위험이 있다. 실제로 누구든 언젠가는 멀티스레딩 환경의 동시성 프로그램을 작성해야 하는 순간이 오는데, 이렇게 멀티 스레딩 환경 코드를 작성할 때 적시에 복사본을 사용하게끔 하는 코드를 작성하면 도움이 된다.<br>

<br>

## 제 3자에 의해 확장될 수 있는 타입일 경우 방어적 복사본을 만들때 `clone` 을 사용하지 않도록 해야 한다.

> final 클래스, final 메서드, final 변수에 대해서는 추후 별도의 문서에 정리해놓을 예정.<br>
>
> [참고: final 클래스, final 메서드, final 필드를 사용하는 이유](https://shrtorznzl.tistory.com/44)<br>

<br>

위에서 사용했던 코드에서는 `clone` 메서드를 사용해 방어적 복사를 하지 않았다. `Date` 클래스는 final 클래스가 아니다. 따라서 악의적이거나, 부적절하게 Date클래스를 상속 받은 후 `clone` 메서드를 재정의 할 수 있다. 그리고 상속받은 하위클래스의 내부에서 재정의한 `clone` 메서드가 `start`, `end` 필드의 참조를 private 정적 리스트 등에 담아두는 등의 코드를 작성하게 되는 경우 역시 무시할 수 없다. 이렇게 되면 악의적인 공격을 허용하는 코드가 되어서 공격자가 이 리스트에 접근해 `start`, `end` 필드의 값을 위변조하게 되어 찾기 어려운 버그를 만들게 될 수 있다는 단점이 있다.<br>

<br>

## ex) 보안취약 사례 2) - 접근자에서 Period 클래스 내부의 값을 변경

예를 들면 아래와 같은 코드가 있다고 해보자

```java
Date start = new Date();
Date end = new Date();
Period p = new Period(start, end);
// end.setYear(77); // 보안취약 사례 1) 에서 사용했던 공격 코드
					 // 외부에서 Date 인스턴스 내부의 정보를 조작했다.

p.end().setYear(79); // 보안 취약 사례 2) 
					 // 외부에서 Period 인스턴스 내부의 Date 타입 필드 end 에 접근해 정보를 조작했다.
```

접근자 메서드로 접근해서 setter를 통해 값을 또 조작했다!!! 이런 코드는 동시성 환경에서 위험하다. 여러개의 스레드가 거의 비슷한 시간에 접근하는 기능의 경우 위의 로직이 적용되면, 의도치 않은 결과를 만들어내기 쉽다.<br>

위의 코드는 아래와 같은 코드로 수정할 수 있다.<br>

```java
public Date start(){
    return new Date(start.getTime());
}

public Date end(){
    return new Date(end.getTime());
}
```

<br>

## 인스턴스를 복사할 때

위에서 살펴 봤듯이 인스턴스를 방어적으로 복사할 때는 가급적 아래의 방법들을 통해 생성하느 것이 권장된다.

- 생성자
- 정적 팩터리 메서드

가급적이면 방어적 복사를 수행하는 코드에서는 clone 메서드를 사용하지 않도록 해야 한다.<br>

단, 접근자 메서드 내에서는 방어적 복사를 수행할 때 clone 메서드를 사용해도 된다. 하지만, `아이템 13. 클론 재정의는 주의해서 진행하라` 에서 설명하는 이유를 고려하면, 인스턴스를 복사할 때는 가급적 생성자, 정적 팩터리 메서드를 사용하는 것이 권장된다.<br>

<br>

## 매개변수의 방어적 복사

매개변수를 방어적으로 복사하는 것은 불변객체를 만들기 위해서만은 아니다. 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 경우에도 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다.<br>

변경될 수 있는 객체일 경우 그 객체가 클래스에 넘겨진 후 임의로 변경되어도 그 클래스가 문제 없이 동작할지를 살펴봐야 한다. 예를 들면 Map, Set 컬렉션 내에 객체를 담을때 Map인스턴스의 키로 사용할 경우 그 객체가 외부에서 변경될 수 있을 경우 Map, Set의 불변식도 깨지게 된다.<br>

<br>

## 내부 객체를 외부에 오픈할 때 역시 방어적 복사

내부 객체를 클라이언트에 건네주기 전에 방어적 복사본을 만드는 것 역시 고려해봐야 한다.<br>

> 위의 예제들 중에서는 `보안취약 사례 2)` 에 해당. 

불변클래스이든, 가변 클래스이든, 가변인 내부 객체를 클라이언트에 반환할 때는 반드시 심사숙고해야 한다. 안심할 수 없다면, 원본을 노출하지말고 방어적 복사본을 반환하게끔 해야 한다.<br>

**길이가 1 이상인 배열은 무조건 가변임을 잊지 말아야 한다.**<br>

따라서, 내부에서 사용하는 배역을 클라이언트에 반환할 경우, 항상 방어적 복사를 수행해야 한다. 또는 배열의 불변 뷰를 반환하는 대안도 있는데, 여기에 관련된 내용은 `아이템 15 - 클래스와 멤버의 접근 권한을 최소화하라` 에서 정리할 예정이다.<br>

**되도록 불변객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다.(아이템 17)** <br>

위에서 정리한 `Period` 클래스 예제의 경우 자바 8 이상에서는 `Instant`, `LocalDateTime` , `ZonedDateTime` 을 사용하면 가변성으로 인한 이슈들을 미연에 방지하기에 용이하다. 불변객체를 지원하는 클래스이기에, `Date` 와 같은 가변객체를 사용할 때보다 변경 여부에 더 예민하게 신경써야 할 요소들이 줄어들게 된다. <br>

<br>





