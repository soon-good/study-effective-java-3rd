# ITEM 73. 추상화 수준에 맞는 예외를 던지라

무턱대고 예외를 전파하는 것보다는 예외 번역이 우수한 방법이지만, 그렇다고 남용해서는 곤란하다. 가능하다면 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다.<br>

또는 상위 레벨 메서드에서 하위 계층 메서드 호출 전에 미리 값들을 체크하고 검증하는 방식으로 로직을 작성하는 것도 좋은 방법이다<br>

만약, 하위 계층에서 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리해 문제를 API 호출자에게까지 전파하지 않는 방법이 있다.<br>

<br>

> 책에서는 여러가지 설명이 많이 있긴 하다. <br>
>
> 우리 주변에서도 예외를 잘 처리한 프레임워크를 볼 수 있다. 내 경우는 스프링 프레임워크를 사용하고 있는데, 스프링 프레임워크는 애플리케이션 로딩시에 발생하는 예외를 잘 출력해주는 친절한 프레임워크라는 생각이 들었다. <br>
>
> 예를 들면, 애플리케이션 구현 시 의존성이 깨지거나, 로딩시에 DataSource에 문제가 있거나, File을 못찾거나 등의 문제에 대해 예외를 로그에 잘 출력해준다.<br>

<br>

## 핵심정리

> 책에서 언급되는 핵심정리.

하위 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라. 이때 예외 번역을 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다. (아이템 75)<br>

<br>

## 저수준 예외를 바깥으로 전파하는 것의 단점

메서드가 저수준 예외를 처리하지 않고 바깥으로 전파하는 경우

- 수행하려는 일과 관련 없어보이는 예외가 튀어나온다.
- 내부 구현 방식을 드러내어, 해당 내용에 맞게 윗 레벨 API를 개발해야 하게끔 만들어 윗 레벨 API를 오염시킨다.

<br>

## 예외번역 (Exception translation)

상위 계층에서 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꾼다.<br>

책에서는 `AbstractSequentialList` 클래스의 `E get (index)` 메서드가 수행하는 예외 번역을 예로 들고 있다.<br>

<br>

```java
public abstract class AbstractSequentialList<E> extends AbstractList<E> {
    // ...
    public E get(int index) {
        try {
            return listIterator(index).next();
        } catch (NoSuchElementException exc) {
            throw new IndexOutOfBoundsException("Index: "+index);
        }
    }
    // ...
}
```

get 메서드에서 발생하는 `NoSuchElementException` 예외를`IndexOutOfBoundsException` 로 상위 호출단에서 에러 판단이 쉽도록 번역해서 처리하고 있다.<br>

<br>

## 예외 연쇄 (Exception Chaining)

문제의 근본 원인(`cause`)인 저수준 예외를 고수준 예외에 실어보내는 방식이다. <br>

예외 번역시 저수준 예외가 예외 처리에 도움이 되면 예외 연쇄를 사용한다.<br>

- 문제의 근본 원인(`cause`)인 저수준 예외를 고수준 예외에 실어보내는 방식이다.
- 이렇게 할  경우 `Throwable` 의 `getCause()` 메서드로 저수준 예외를 꺼내볼 수 있다.
- 예외 연쇄를 사용하면 생성자를 연쇄적으로 호출하게 되면서 최종적으로 `Throwable(cause)` 가 호출된다.
- 또는 `initCause(cause)` 메서드를 사용한다.

