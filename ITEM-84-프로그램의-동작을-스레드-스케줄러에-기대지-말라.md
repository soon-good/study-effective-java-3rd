# Item 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라

요즘 정말 시간이 많지 않다. 점심시간+오전에  잠깐 정리했던 내용을 조금 더 정리해서 일단 커밋부터 해보려 한다.<br>

<br>

## 참고자료

- [이펙티브 자바 Effective Java](http://www.yes24.com/Product/Goods/65551284)

<br>

## 읽어볼 만한 자료

- [7가지 동시성 모델](https://ridibooks.com/books/443000364)

동시성과 병렬성에 대해 쉽게 풀어서 설명하고 있는 책이다. 잘 모르겠다는 생각을 하던것들에 대해 잘 설명해주고 있는데, 평소에 궁금하다고 생각했던 것들을 짚어주고 있다. 실제 최신 CPU들에도 CPU 내부의 명령어 파이프라인 안에서도 1코어 내에서 병렬적으로 실행될수 있도록 개선되었다는 이야기 등등 재밌는 내용들이 많다. 시간이 될때 필요한 부분만 동시성 파트에 해당 내용들을 조금씩만 요약해둬야 겠다는 생각이 들었다.<br>

<br>

## 핵심 정리

프로그램의 동작을 스레드 스케쥴러에 기대지 말자. 견고성과 이식성을 모두 해치는 행위다.<br>

같은 이유로 Thread.yield 와 스레드 우선순위에 의존해서도 안된다.<br>

이 기능은 스레드 스케쥴러에 제공하는 힌트일 뿐이다.<br>

스레드 우선순위는 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 쓰일 수는 있지만, 간신히 동작하는 프로그램을 '고치는 용도'로 사용해서는 절대 안된다.<br>

<br>

## 스레드 스케쥴러에 의존적인 기능을 작성하지 말자

OS의 스레드 스케쥴러에 의존적인 프로그램은 운영체제마다 스케쥴링 정책이 달라질 수 있다. 따라서 잘 작성된 프로그램이라면 운영체제마다 다른 스레드 스케쥴링 정책에 좌지 우지 되면 안된다. 정확성이나 성능이 OS 종류에 따라 다른 스레드 스케쥴러마다 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.<br>

OS에 기반한 스레드 스케쥴러가 아닌, JVM위에서 작성한 스레드 스케쥴러라면 여기에 해당하지는 않는다. 책의 서두에서 언급하고 있는데, 책에서 이야기하는 내용은 엉뚱하게 자바 프로그램에서 pthread 스레드를 돌린다든가, exe 파일이나 바이너리 파일을 돌리는 뭔가 이상한 로직을 실행할 가능성을 이야기하는 것이 아닌가 싶다.<br>

> 이것은 Java 에 한정된 이야기 인것 같다. C언어의 경우 cpu 아키텍쳐에 따라서 컴파일 방식이 달라지기도 하고, VM을 사용하지 않는 언어에는 해당되지 않는 이야기인 것 같다. 

<br>

## 스레드가 적용되었어도, 이식성 좋은 프로그램

물리적인 머신의 프로세서 수 보다 실행 가능한 스레드의 평균적인 수가 더 적어야 스레드 스케쥴러가 고민할 거리가 줄어든다.

- 물리 머신의 프로세서 수 >= 실행 가능한 스레드의 평균적인 수 

<br>

실행 준비가 된 스레드는 작업 완료 될 때 까지 계속 실행되도록 만들어두어야 한다.

- 이렇게 해두면, 스레드 스케쥴링 정책이 다른 시스템에서도 동작이 크게 달라지지 않는다.

<br>

실행가능한 스레드의 수와 전체 스레드의 수는 구분해야 한다. 전체 스레드 수는 더 많을 수 있고, 대기중인 스레드는 실행 가능하지 않다(=대기중인 스레드 대신 실행 준비가 된 스레드로 준비해두어야 한다.).

<br>

## 실행가능한 스레드 수 관리 요령

실행 가능한 스레드 수 를 코드 상에서 직접 지정하거나 코드 상에서 스레드를 관리하는 방법은 애매한 요인 중 하나인 것 같다. 책에서는 실행 가능한 스레드의 수를 관리하는 방식에 대해서 설명한다.<br>

- 스레드 풀을 두어서 작업 완료시 다음 일거리가 생길 때 까지 대기하도록 코드를 작성한다.
  - 스레드는 당장 처리해야 할 작업이 없다면 실행되어서는 안된다. 따라서 다음 일거리가 생기기 전까지 대기하게끔 해둔다.
  - ITEM 80. 스레드보다는 실행자/태스크/스트림을 애용하라
    - 실행자(Executor) 프레임워크를 예로 들면, 스레드 풀 크기를 적절히 설정하고 작업을 짧게 유지한다. 
    - 단, 작업이 너무 짧으면 작업을 분배하는 부담이 성능저하의 원인이 되기도 한다.
- 스레드는 절대 바쁜 대기(busy waiting) 상태가 되면 안된다.
  - 공유 객체 또는 공유 변수가 변할 때까지 계속해서 검사하는 코드를 작성하면 안된다. 
  - 이것을 책에서는 바쁜 대기(busy waiting) 이라는 용어로 설명하고 있다.
  - 바쁜 대기 (busy waiting)는 스레드 스케쥴러의 변덕에 취약하고, 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회를 박탈한다.

<br>

## busy waiting 을 하는 나쁜 코드의 예

```java
package effectivejava.chapter11.item84;

// Awful CountDownLatch implementation - busy-waits incessantly!  - Pages 336-7
public class SlowCountDownLatch {
    private int count;

    public SlowCountDownLatch(int count) {
        if (count < 0)
            throw new IllegalArgumentException(count + " < 0");
        this.count = count;
    }

    public void await() {
        while (true) {
            synchronized(this) {
                if (count == 0)
                    return;
            }
        }
    }
  
    public synchronized void countDown() {
        if (count != 0)
            count--;
    }
}
```

<br>

위의 코드에서 busy waiting을 하고 있는 코드는 아래와 같다. if 구문으로 count 변수를 while 문에서 무한반복으로 조사하는데 여기에 조건변수의 동기화가 필요하기에 synchronized 키워드를 적용하고 있다.

```java
public void await() {
  while (true) {
    synchronized(this) {
      if (count == 0)
        return;
    }
  }
}
```

<br>

더 자세히 정리했으면 좋겠는데, 그렇게 시간이 많지가 않다. 일단은 이정도까지.

<br>

## Thread.yield 또는 우선순위

특정 스레드가 다른 스레드 들에 밀려서 작업권을 뺏기는 경우가 있다. 다른 스레드 들에 비해 CPU 시간을 충분히 얻지 못해 간신히 돌아가는 경우를 예로 들 수 있다. 이때 Thread.yield 로 특정 작업의 우선순위를 임의로 조정하는 경우가 있는데 좋지 못한 해결 방식이다.<br>

Thread.yield 를 써서 문제를 고쳐보려는 유혹을 떨쳐내야 한다.<br>

이건 조금 글이 길어지기에 내일 이후로 정리해야 할 것 같다. 선점형, 선점형 스케쥴러 등등 이것 저것 정리해야 하는 이론들이 떠오르지만, 간결하게 정리해야하고, 일단 시간은 또 없고, 일단 내일 이후로 스킵.<br>

<br>
