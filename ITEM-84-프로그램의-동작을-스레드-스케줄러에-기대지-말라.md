# Item 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라

요즘 정말 시간이 많지 않다. 점심시간+오전에  잠깐 정리했던 내용을 조금 더 정리해서 일단 커밋부터 해보려 한다.<br>

<br>

## 참고자료

- [이펙티브 자바 Effective Java](http://www.yes24.com/Product/Goods/65551284)

<br>

## 읽어볼 만한 자료

- [7가지 동시성 모델](https://ridibooks.com/books/443000364)

동시성과 병렬성에 대해 쉽게 풀어서 설명하고 있는 책이다. 잘 모르겠다는 생각을 하던것들에 대해 잘 설명해주고 있는데, 평소에 궁금하다고 생각했던 것들을 짚어주고 있다. 실제 최신 CPU들에도 CPU 내부의 명령어 파이프라인 안에서도 1코어 내에서 병렬적으로 실행될수 있도록 개선되었다는 이야기 등등 재밌는 내용들이 많다. 시간이 될때 필요한 부분만 동시성 파트에 해당 내용들을 조금씩만 요약해둬야 겠다는 생각이 들었다.<br>

<br>

## 핵심 정리

프로그램의 동작을 스레드 스케쥴러에 기대지 말자. 견고성과 이식성을 모두 해치는 행위다.<br>

같은 이유로 Thread.yield 와 스레드 우선순위에 의존해서도 안된다.<br>

이 기능은 스레드 스케쥴러에 제공하는 힌트일 뿐이다.<br>

스레드 우선순위는 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 쓰일 수는 있지만, 간신히 동작하는 프로그램을 '고치는 용도'로 사용해서는 절대 안된다.<br>

<br>

## 스레드 스케쥴러에 의존적인 기능을 작성하지 말자

점심시간 10분 전에 잠깐 시간내서 다시 정리를 시작했다. `ITEM 84`를 잘 정리하지 못하고 쉬어서 주말에도 찜찜하긴 했는데, 잠깐 시간을 내서 조금 다시 정리해보면 아래와 같다.

**스레드 스케쥴러란?**<br>

 ITEM 84 에서 이야기하는 스레드 스케쥴러는 JVM 도 해당되고 OS도 해당된다. 책에서는 모호하게 OS의 스레드 스케쥴러인지, JVM의 스레드 스케쥴러인지는 언급하지는 않았다. JVM 내부에는 스레드를 스케쥴링하는 기능이 있다. 스레드 스케쥴러에 의존적인 기능이라는 것은 이 JVM의 스레드 스케쥴러를 의미한다. <br>

(Java의 경우 JVM위에서 동작하기에, JVM의 스레드 스케쥴러를 의미하는 것이지만, 만약 C/C++ 일 경우를 생각해본다면, C/C++ 은 VM이 없으니, `OS의 스케쥴러에 의존적인 기능을 작성하지 말아야 한다.` 라고 이해하면 될 것 같다.)<br>

**스레드 스케쥴러에 의존적인 기능이란?**<br>

예를 들어 java 에는 스레드의 우선순위를 임의로 조작하는 Thread.yield() 라는 함수가 있다. 이 Thread.yield() 는 현재 실행 중인 스레드를 스케쥴러가 다른 프로세서에 양보할 수 있도록 우선순위를 양보하는 것 이라고 생각하면 좋을 것 같다.<br>

가끔 멀티 스레드 기반으로 기능을 구현할 때, 여러개로 풀어놓은 스레드가 순서를 가지고 제어되어야 하는 경우가 있는데, 이때 감으로 우선순위를 단지 yield 하는 경우가 있다. 이런 경우 JVM은 가끔은 의도한 대로 동작하지만, 어떤 경우는 전혀 기대하지 않은 동작으로 동작할 때가 있다. <br>

스레드 스케쥴러의 동작에 결과의 기댓값을 기대지 말라는 것은 이것과 유사한 의미다. 좀 더 정리해야 하는데, 부연 설명은 조금 나중에 다시 돌아와서 정리해야 할 것 같다.<br>

<br>

## 스레드가 적용되었어도, 이식성 좋은 프로그램

물리적인 머신의 프로세서 수 보다 실행 가능한 스레드의 평균적인 수가 더 적어야 스레드 스케쥴러가 고민할 거리가 줄어든다.

- 물리 머신의 프로세서 수 >= 실행 가능한 스레드의 평균적인 수 

<br>

실행 준비가 된 스레드는 작업 완료 될 때 까지 계속 실행되도록 만들어두어야 한다.

- 이렇게 해두면, 스레드 스케쥴링 정책이 다른 시스템에서도 동작이 크게 달라지지 않는다.

<br>

실행가능한 스레드의 수와 전체 스레드의 수는 구분해야 한다. 전체 스레드 수는 더 많을 수 있고, 대기중인 스레드는 실행 가능하지 않다(=대기중인 스레드 대신 실행 준비가 된 스레드로 준비해두어야 한다.).

<br>

## 실행가능한 스레드 수 관리 요령

실행 가능한 스레드 수 를 코드 상에서 직접 지정하거나 코드 상에서 스레드를 관리하는 방법은 애매한 요인 중 하나인 것 같다. 책에서는 실행 가능한 스레드의 수를 관리하는 방식에 대해서 설명한다.<br>

- 스레드 풀을 두어서 작업 완료시 다음 일거리가 생길 때 까지 대기하도록 코드를 작성한다.
  - 스레드는 당장 처리해야 할 작업이 없다면 실행되어서는 안된다. 따라서 다음 일거리가 생기기 전까지 대기하게끔 해둔다.
  - ITEM 80. 스레드보다는 실행자/태스크/스트림을 애용하라
    - 실행자(Executor) 프레임워크를 예로 들면, 스레드 풀 크기를 적절히 설정하고 작업을 짧게 유지한다. 
    - 단, 작업이 너무 짧으면 작업을 분배하는 부담이 성능저하의 원인이 되기도 한다.
- 스레드는 절대 바쁜 대기(busy waiting) 상태가 되면 안된다.
  - 공유 객체 또는 공유 변수가 변할 때까지 계속해서 검사하는 코드를 작성하면 안된다. 
  - 이것을 책에서는 바쁜 대기(busy waiting) 이라는 용어로 설명하고 있다.
  - 바쁜 대기 (busy waiting)는 스레드 스케쥴러의 변덕에 취약하고, 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회를 박탈한다.

<br>

## busy waiting 을 하는 나쁜 코드의 예

```java
package effectivejava.chapter11.item84;

// Awful CountDownLatch implementation - busy-waits incessantly!  - Pages 336-7
public class SlowCountDownLatch {
    private int count;

    public SlowCountDownLatch(int count) {
        if (count < 0)
            throw new IllegalArgumentException(count + " < 0");
        this.count = count;
    }

    public void await() {
        while (true) {
            synchronized(this) {
                if (count == 0)
                    return;
            }
        }
    }
  
    public synchronized void countDown() {
        if (count != 0)
            count--;
    }
}
```

<br>

위의 코드에서 busy waiting을 하고 있는 코드는 아래와 같다. if 구문으로 count 변수를 while 문에서 무한반복으로 조사하는데 여기에 조건변수의 동기화가 필요하기에 synchronized 키워드를 적용하고 있다.

```java
public void await() {
  while (true) {
    synchronized(this) {
      if (count == 0)
        return;
    }
  }
}
```

<br>

더 자세히 정리했으면 좋겠는데, 그렇게 시간이 많지가 않다. 일단은 이정도까지.

<br>

## Thread.yield 또는 우선순위

특정 스레드가 다른 스레드 들에 밀려서 작업권을 뺏기는 경우가 있다. 다른 스레드 들에 비해 CPU 시간을 충분히 얻지 못해 간신히 돌아가는 경우를 예로 들 수 있다. 이때 Thread.yield 로 특정 작업의 우선순위를 임의로 조정하는 경우가 있는데 좋지 못한 해결 방식이다.<br>

Thread.yield 를 써서 문제를 고쳐보려는 유혹을 떨쳐내야 한다.<br>

이건 조금 글이 길어지기에 내일 이후로 정리해야 할 것 같다. 선점형, 선점형 스케쥴러 등등 이것 저것 정리해야 하는 이론들이 떠오르지만, 간결하게 정리해야하고, 일단 시간은 또 없고, 일단 내일 이후로 스킵.<br>

<br>
