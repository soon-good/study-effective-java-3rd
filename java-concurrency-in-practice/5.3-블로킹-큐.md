# 5.3 블로킹 큐

> 오늘 정리하는 내용은 1차 요약이다. 2차 정리를 시작할때 내용을 다듬어야지.

블로킹 큐는 프로듀서-컨슈머(producer-consumer) 패턴을 구현할 때 사용하기에 좋다. 블로킹 큐는 애플리케이션이 안정적으로 동작하고자 만들려 할 대 요긴하게 사용될 수 있는 도구다. 블로킹 큐를 사용하면 처리할 수 있는 양보다 훨씬 많은 작업이 생겨 부하가 걸릴때 작업량을 조절해 애플리케이션이 안정적으로 동작하도록 유도하는 것이 가능하다.<br>

<br>


## 프로듀서 - 컨슈머 패턴

프로듀서-컨슈머 패턴을 사용하면 작업을 만들어내는 부분과 작업을 처리하는 부분을 완전히 분리할 수 있기때문에 개발 과정을 좀 더 명확하게 단순화시킬수 있고, 작업을 생성하는 부분과 처리할 수 있는 부분이 각각 감당할 수 있는 부하를 조절할 수 있다는 장점이 있다.<br>

프로듀서-컨슈머 패턴은 큐를 사이에 두고 생산자와 소비자가 간접적으로 동작하도록 연결되어 있다.<br>

<br>

## 프로듀서-컨슈머 패턴에 블로킹 큐의 활용

프로듀서-컨슈머 패턴을 적용해 프로그램을 구현할 때 블로킹 큐를 사용하는 경우가 많은 편이다. 예를 들면 프로듀서는 작업을 새로 만들어 큐에 쌓아두고, 컨슈머는 큐에 쌓여 있는 작업을 가져다가 처리하는 구조.<br>

큐와 함께 스레드 풀을 사용하는 경우가 바로 프로듀서-컨슈머 패턴을 활용하는 가장 흔한 경우다. 작업 큐와 스레드 풀을 사용하는 부분은 Executor 프레임웍에 대해 다루는 6장,8장 에서도 자세히 다루고 있다.<br>

단순히 컨슈머가 항상 밀리지 않고 작업을 처리한다고 가정하고 작업 큐에 제한을 둘 필요가 없을 것이라고 마음 편하게 넘어가는 경우가 있을 수 있다. 하지만 이런 가정을 하는 순간 나중에 프로그램 구조를 뒤집어 엎어야 하는 원인을 하나 남겨두게 되는 것 뿐이니 주의해야 한다. 블로킹 큐를 사용해 프로그램 설계 과정에서부터 자원관리 기능을 추가하자. 나중에 닥쳤을 때 허겁지겁 자원관리 기능을 추가하려 애쓰는 대신 간단한 작업으로 앞으로 다가올 큰 부하를 처리하도록 준비할 수 있다.<br>

<br>

**참고: 세마포어**<br>

대다수의 경우에는 블로킹 큐만 사용해도 원하는 기능을 쉽게 구현할 수 있다. 하지만 프로그램이 블로킹 큐를 쉽게 적용할 수 없는 모양새를 갖고 있다면, 세마포어(Semaphore)를 사용해 사용하기 적합한 데이터 구조를 만들어야 한다.<br>

<br>

## 대표적인 BlockingQueue 의 구현체 클래스들

아래 클래스들은 Java 플랫폼에서 기본으로 제공하는 `BlockingQueue` 를 구현한 구체 클래스들이다.<br>

- `LinkedBlockingQueue`
- `ArrayBlockingQueue`
- `PriorityBlockingQueue`
- `SynchronousQueue`

<br>

**`LinkedBlockingQueue`, `ArrayBlockingQueue`**<br>

FIFO 형태의 큐. Java 라이브러리의 `LinkedList`, `ArrayList` 와 각각 대응되는 컬렉션이다. `LinkedList`, `ArrayList` 에 비해 병렬 프로그램 환경에서 동기화된 List 인스턴스를 뽑아 사용하는 것보다 성능이 좋다.<br>

**`PriorityBlockingQueue`**<br>

우선순위를 기준으로 동작하는 큐. FIFO 기반이 아닌 우선순위를 기반으로 큐의 항목을 enqueue, dequeue 한다.기본 정렬 순서로 정렬시키거나 아니면 Comparator 인터페이스를 사용해 정렬시킬 수 있다.<br>

**`SynchronousQueue`** <br>

`BlockingQueue` 인터페이스를 구현하고 있는 클래스다. 차이점은 이렇다. 큐에 아이템이 쌓이지 않는다. 그리고 큐 내부에 값을 저장할 수 있도록 공간을 할당하지도 않는다. 대신 큐에 값을 추가하려는 스레드나 값을 읽어가려는 스레드의 큐를 관리한다.<br>

`Executors` 에서 제공하는 `newCachedThreadPool` 이 작업 큐로 `SynchronousQueue` 를 사용하고 있다. `newCachedThreadPool` 에 관련되어서는 6장, 8장에서 자세히 다루고 있다.<br>

`SynchronousQueue` 에는 큐에 추가된 데이터를 보관할 공간이 없기 때문에 `put` 메서드나 `take` 메서드를 호출하면 호출한 메서드의 상대편 측에 해당하는 메서드를 다른 스레드가 호출할 때까지 대기한다. 즉, `SynchronouseQueue` 를 사용할 때에는 데이터를 넘겨받을 수 있는 충분한 갯수의 컨슈머(작업자 스레드)가 대기하고 있는 경우에 사용하기 좋다.<br>

만약 작업자 스레드의 갯수가 무한하게 생성할 수 없고, 컨슈머가 작업을 처리하는 속도가 느린데도 프로듀서가 생성하는 작업은 무한히 늘어난다면, `SynchronousQueue` 를 사용하기에는 좋은 구조가 아니다. 이런 경우는 문제의 제한점을 잘 파악하면, 고정된 풀로도 해결할 수 있는 경우다. SynchronousQueue 는 제한된 생산/제한된 소비 상에서 효율적인 퍼포먼스를 보이기 위한 구조인 것 같다.)<br>

<br>

## 블로킹 큐의 주요 메서드 들

블로킹 큐에는 put, take, offer, poll 메서드가 있다. <br>

**put 메서드**<br>

값을 추가할 공간이 생길 때 까지 대기한다.<br>

큐의 공간이 제한이 없다면 put 메서드가 대기할 일은 발생하지 않는다.<br>

**take 메서드**<br>

큐가 비어있을 때는 뽑아낼 값이 들어올 때 까지 대기한다.<br>

**offer 메서드**<br>

- 큐에 값을 넣을 수 없을 때 대기하지 않고 바로 공간이 모자라 추가할 수 없다는 오류를 알려준다.<br>
- offer 메서드를 잘 활용하면 프로듀서가 작업을 많이 만들어 과부하에 이르는 상태를 좀 더 효과적으로 처리할 수 있다. <br>
- 예를 들면 부하를 분배하거나 작업할 내용을 json같은 데이터구조로 직렬화(serialize) 해서 디스크에 임시로 저장해두거나, 프로듀서 스레드의 수를 동적으로 줄이거나, 기타 여러가지 방법을 사용해 프로듀서가 작업을 생성하는 양을 조절할 수 있다.<br>
- 개인적으로는 put 메서드에 비해 offer 메서드가 프로그래머 입장에서는 다양한 상황에 대한 예외처리를 하는 등의 작업을 할 수 있다는 점에서 더 장점이 명확한 것 같다.<br>

<br>

**poll() 메서드**<br>

poll() 을 사용하면 아이템을 가져올 때 Timeout 을 설정해 무한히 기다리는 일이 발생하지 않도록 하는 것이 가능하다. 예를 들면 poll(int timeout) 메서드를 사용하면 아이템을 가져올 때 일정시간을 대기할 수 있도록 구현할 수 있다. 자세한 내용은 [codechacha - Java - ArrayBlockingQueue 사용방법](https://codechacha.com/ko/java-arrayblockingqueue/) 을 참고하자.

<br>

<hr/>

뒤의 내용도 정리해야 하는데 잠시 스킵
