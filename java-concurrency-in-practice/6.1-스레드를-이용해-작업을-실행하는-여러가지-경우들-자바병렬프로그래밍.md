# 6.1 스레드를 이용해 작업을 실행하는 여러가지 경우들

서버 애플리케이션은 한정된 자원을 효율적으로 사용해야 한다.

task : 논리적인 업무의 단위

스레드를 사용해 작업을 실행시키는 두가지 방법
- 하나의 스레드에서 여러 작업을 순차적으로 실행하는 방식
- 각 작업을 각각의 스레드에서 실행시키는 방법

Executor 는 여러가지 종류의 작업 실행 정책을 지원하는 유연하면서도 강력한 비동기적 작업 실행 프레임워크의 근간을 이루는 인터페이스다. 

Executor 는 작업 등록(task submission)과 작업 실행(task execution) 을 분리하고 있는 표준적인 방법이고, 각 작업은 Runnable 또는 Callable의 형태로 정의한다.

Executor 를 구현한 클래스는 여러가지 기능을 가지고 있다.
- 작업의 라이프 사이클을 관리하는 기능
- 몇가지 통계값을 뽑아내는 기능
- 애플리케이션의 작업 실행과정을 관리/모니터링하는 기능

Executor 의 구조는 프로듀서-컨슈머 패턴에 기반하고 있다. 작업을 생성해 등록하는 클래스가 프로듀서(처리해야 할 작업을 생성하는 주체)가 되고 작업을 실제로 실행하는 스레드가 컨슈머(생성된 작업을 처리하는 주체)가 되는 모양을 갖추고 있다. 일반적으로 프로듀서-컨슈머 패턴을 애플리케이션에 적용해 구현할 수 있는 가장 쉬운 방법이 Executor 프레임워크를 사용하는 방식이다.

작업을 등록하는 부분과 실행하는 부분을 서로 분리시켜 두면 특정 작업을 실행하고자 할 때 코드를 많이 변경하거나 여러가지 어려운 상황을 겪지 않으면서도 실행 정책(execution policy)을 언제든지 변경할 수 있는 장점이 있다.

프로그램의 어디서든 아래와 같은 코드가 있다면 조만간 이런 부분에 유연한 실행 정책을 적용할 준비를 해야 한다. 그리고 나중을 위해서 Executor 를 사용해 구현하는 방안을 고려해봐야 한다.

```java
new Thread(runnable).start();
```

<br>

## 6.1 스레드를 이용해 작업을 실행하는 여러가지 경우들

> 원서 : Executing Tasks in Threads

**서버 애플리케이션 = 높은 처리량과 빠른 반응속도를 만족해야 한다.**
서버 애플리케이션은 즉각적으로 원하는 서비스를 응답할 수 있어야한다. 또는 서버 애플리케이션에 부하가 가해지는 상황에서는 그냥 죽어버려서는 안되고 부하에 따라 성능이 점진적으로 떨어지도록 설계되어 있어야 한다. 서버 애플리케이션이 이와 같은 특성을 가지려면, 작업의 범위를 적절하게 설정해야 하고, 작업을 실행하는 정책(task execution policy - 6.2.2 절)을 면밀하게 구성해두어야 한다. 

**작업의 범위 구성**
프로그램에서 일어나는 일을 작업이라는 단위로 재구성하고자 한다면 가장 먼저 해야 할 일은 작업의 범위를 어디까지로 해야 할 것인지 정하는 일이다. 원론적으로 보자면 작업은 완전히 독립적인 동작을 말한다. 말하자면 다른 작업의 상태, 결과, 부수효과 등에 영향을 받지 않아야 한다. 이런 독립성이 갖춰져 있어야 병렬성을 보장할 수 있다.  독립적인 작업이 되어야 적절한 자원이 확보된 상태에서 병렬로 수행될 수 있다.

작업을 스케쥴링하거나 부하 분산(load balancing)하고자 할 때 유연성을 얻으려면, 각 작업이 애플리케이션의 전체적인 업무 내용 가운데 충분히 작은 부분을 담당하도록 구성되어 있어야 한다.

**ex) 메일 서버**
예를 들면 메일 서버에 하나의 메시지를 전송하고 그 결과를 받는 작업은 다른 클라이언트가 동시에 메시지를 주고받는 일과 아무런 관련 없이 처리될 수 있다. 또한 메일 서버의 입장에서는 단일 메시지를 처리하는 작업이 전체 사용 가능한 용량 가운데 아주 작은 일부분을 차지할 뿐이다.

<br>

### 6.1.1 순차적인 작업 실행

> 원서 : Executing Tasks Sequentially
> 번역서에서는 '작업을 순차적으로 실행' 이라고 적혀있는데, 임의로 이번 절의 이름을 순차적인 작업 실행 이라고 변경했다.

대부분의 서버에서는 이런 순차적인 구조의 작업실행은 사용하지 않는다.

작업을 실행하는 간단한 방법은 단일 스레드에서 작업 목록을 순차적으로 실행하는 방법이다. 아래의 SingleThreadWebServer.java 가 이런 방법이다. 이 예에서는 클라이언트의 요청에 대한 처리 결과는 그리 중요하지 않게끔 코드가 작성되어 있다.

```java
class SingleThreadWebServer {
    public static void main(String [] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while(true){
            Socket connection = socket.accept();
            handleRequest(connection);
        }
    }
}
```

SingleThreadWebServer 클래스는 한번에 하나의 요청만을 처리할 수 있기에 실제 상황에서는 성능이 매우 떨어지게 된다.  기본 스레드(base thread) 는 네트워크 소켓 연결을 기다리고 있다가 클라이언트가 보내온 요청을 처리하는 과정을 반복하고 있다.(반복문에서 순회)

만약 웹서버가 이전 클라이언트 A 의 요청을 처리하는 도중에 새로 요청을 전송한 클라이언트 B의 요청은 웹서버가 이전 요청을 처리하기 까지 기다려야 한다. handelRequest 메서드가 거의 즉시 처리를 끝낸다면 웹 서버가 어느 정도 역할을 할 수도 있겠지만, 그런 환경은 실제로는 거의 볼수 없다.

서버에서 클라이언트의 요청을 처리할 때에는 대부분 I/O 연산이 대부분을 차지한다. 주로 네트워크 I/O, 데이터베이스 I/O 작업들이 많다. 이런 작업들은 대부분 대기상태로 들어갈 가능성이 있는 기능이다. 단일 스레드로 처리하는 도중에는 어떤 작업이든 대기 상태에 들어간다는 것은 처리 시간이 길어진다는 문제 뿐만 아니라 다른 요청을 전혀 처리 하지 못한다는 문제를 의미한다.

서버애플리케이션은 순차적인 처리방법을 사용할 때 앞에서 언급한 높은 처리량과 빠른 반응속도 가운데 어느것도 제대로 만족하지 못한다.

<br>

### 6.1.2 작업마다 스레드를 직접 생성

> 원서 : Explicitly Creating Threads fo Tasks

반응속도를 훨씬 높이기 위한 첫번째 접근 방식
요청이 들어올 때마다 새로운 스레드를 생성해서 작업을 실행하는 방식이다.
이렇게 하면 웬만한 부하까지는 견딜수 있고, 순차적인 실행방법에 비하면 속도가 크게 향상된다.

하지만, 클라이언트가 서버에 요청을 전송하는 속도보다 응답을 전송하는 속도가 더 빨라야 한다는 제약 조건이 존재한다.
- 이런 제약 조건이 지켜진다는 전제조건이 있다면,  괜찮은 응답속도와 성능을 보이게 된다.

상용서비스에서 사용하기에는 다소 무리가 있다.
- 특정상황에서 엄청나게 많은 양의 스레드가 생성될 수 있는데, 이 경우 아래의 세가지 문제가 발생한다.
	- 스레드 라이프 사이클 문제
	- 자원 낭비
	- 안정성 문제

아래의 ThreadPerTaskWebServer 는 이렇게 구현되어 있다.

```java
class ThreadPerTaskWebServer{
    public static void main(String [] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while(true){
            final Socket connection = socket.accept();

            Runnable task = new Runnable(){
                public void run(){
                    handleRequest(connection);
                }
            };

            new Thread(task).start();
        }
    }
}
```

클라이언트의 요청 내용을 메인스레드에서 직접 처리하지 않고 클라이언트가 접속할 때마다 반복문에서 해당 클라이언트의 요청 처리를 담당하는 새로운 스레드를 매번 생성한다는 차이점이 있다. 이렇게 변경하면 크게 세 가지 결과를 얻을 수 있다.

- 작업을 처리하는 기능이 메인스레드에서 빠져나온다.
- 동시에 여러 작업을 병렬로 처리할 수 있기 때문에 두 개 이상의 요청을 받아 동시에 처리할 수 있다.
- 실제 작업을 처리하는 스레드의 프로그램은 여러 클라이언트가 접속하는 겨우 동시에 동작할 가능성이 높기 때문에 스레드 안전성을 확보해야 한다.

<br>

### 6.1.3 스레드를 많이 생성할 때의 문제점

> 원서 : Disadvantages of Unbounded Thread Creation

요청 하나에 대해 스레드 하나를 즉시 생성해서 작업을 처리하는 구조는 상용 서비스에서 사용하기에는 다소 무리가 있다. 특정 상황에서 스레드가 엄청나게 많은 양이 생성될 수 있다. 이렇게 엄청나게 많은 양의 스레드가 생성될 경우의 단점은 아래의 세가지다.

- 스레드 라이프 사이클 문제
- 자원 낭비
- 안정성 문제

<br>

**스레드 라이프 사이클 문제**
스레드를 생성하고 제거하는 작업에도 자원이 소모된다.
스레드의 생성과 제거에 소모되는 자원은 OS마다 다르지만, 스레드를 생성하는 과정에는 일정량의 시간이 필요하다. 
클라이언트의 요청 처리시 기본적인 딜레이가 생기는데, 이 때 JVM, OS 는 몇가지 기초적인 작업을 진행한다.
요청에 대한 작업이 간단하고 빈도가 높은 작업이면, 스레드를 자주 생성하게 되어 스레드 생성하는 작업이 전체 작업에서 많은 부분을 차지하게 된다.

<br>

**자원낭비**
실행 중인 스레드는 시스템의 자원을 사용하는데 그 중 특히, 메모리를 소모한다.
실제로 장착된 CPU 의 수보다 많은 수의 스레드가 만들어져 동작중일 경우, 실제로는 대부분의 스레드가 대기(idle) 상태에 머무르게 된다.
대기(idle)상태에 머무르는 스레드가 많아질 수록 많은 메모리를 필요로 하게 된다. JVM 의 가비지 컬렉터에 가해지는 부하가 커진다.
CPU 를 사용하기 위해 여러 스레드가 경쟁하는 모양이 되므로 메모리 이외에도 많은 자원이 필요해진다.
CPU의 갯수에 해당하는 스레드가 동작 중이라면, 스레드를 더 만들어 내도 성능이 직접 적으로 개선되지 않을 수 있고 오히려 악영향을 미칠 가능성이 크다.

<br>

**안정성 문제**
모든 시스템은 생성할 수 있는 스레드의 갯수가 제한되어 있다.

- 몇 개까지 만들 수 있는지는 플랫폼, 운영체제마다 다르다.
- JVM 을 실행할 때 지정하는 인자나 Thread 클래스에 필요한 스택의 크기에 따라서 달라지기도 한다.
- 제한된 양을 모두 사용하고나면 OutOfMemoryError 가 발생한다. OutOfMemoryError 가 발생한 상황에서 해당 오류를 잡을 수 있는 방법은 별로 없고 가능하다 해도 안정적으로 처리하기 어렵다.

스레드를 무한대로 요청이 올때마다 생성해서 사용하는 방식은 개발 과정에서는 문제가 없을 수 있지만, 실제 상황, 상용서비스에서 엄청난 부하가 가해졌을때 문제가 발생하게 된다. 악의적인 사용자 뿐만 아니라 일반적인 사용자의 요청량도 늘어가는 상황이라면, 웹서버는 충분히 다운될 수 있는 상황에 도달할 수 있게 된다. 항상 높은 가용성을 유지하고, 부하가 높은 상황에서도 성능을 점전적으로 떨어지게 해야 할 서버 애플리케이션이 이런 문제가 발생하면 치명적인 오류가 될 수 있다.

<br>

**스레드를 생성할 수 있는 갯수의 제한**
32비트 시스템의 예를 들어서 정리해보면 이렇다. 32비트 시스템에서 가장 큰 제약 요소는 스레드 스택에 적용되는 주소공간이다. 모든 스레드는 Java 코드와 Native 코드를 실행할 수 있도록 두개의 스택을 갖는다. 이 것은 일반적인 JVM의 기본값으로 보면 두 개의 스택을 더한 용량이 일반적으로 대략 0.5MB 정도 된다.

이 값은 jvm 을 실행할 때 -Xss 옵션을 지정하거나 Thread 클래스를 생성할 때 생성 메서드에 지정하는 값으로 변경 가능하다.

예를 들어 스레드별 스택 크기를 2^32 (32비트 시스템)로 나눈 값으로 설정하면, 수천개, 수만개의 스레드를 사용할 수 있다.  운영체제 등에서 제한하는 여러가지 제약 조건은 훨씬 엄격하게 적용될 수 있다.

```plain
2^30 = 1 나노, 2^2 = 4, 1나노 x 2^2 = 2^32, 4 나노
```

<br>

