# 8.3.4 스레드 팩토리

`Thread` 객체를 직접 만들어서 사용해야 하는 경우 스레드 팩토리 메소드를 사용해야 한다.<br>

<br>

## ThreadFactory

Executor 를 이용해 생성한 스레드 풀 내에서 새로운 스레드를 생성할 때 새로운 스레드는 항상 스레드 팩토리를 이용해 생성한다. `ThreadFactory` 는 아래와 같은 모습이다.

```java
public interface ThreadFactory{
    Thread newThread(Runnable r);
}
```

<br>

`ThreadFactory` 를 직접 구현해 사용하면 스레드 풀에서 사용할 `Thread` 객체의 설정을 원하는 대로 지정할 수 있다. `ThreadFactory` 클래스에는 `newThread` 라는 메소드 하나만 정의되어 있다. 스레드 풀에서 새로운 스레드를 생성시 항상 `newThread` 메서드를 사용한다.

<br>

## 스레드 팩토리 메서드를 직접 작성해 사용해야 하는 경우

Thread 를 생성하는 스레드 팩토리를 직접 작성해야 하는 경우는 아래와 같은 경우들이다

- 스레드에 `UncaughtExceptionHandler` 를 직접 지정하고자 하는 경우
- `Thread` 클래스를 상속받는 또 다른 클래스를 생성해 사용하고자 하는 경우
- 새로 생성한 스레드의 실행 우선순위를 조절 (권장되지 않음) 하려는 경우
- 데몬 상태를 직접 지정(권장되지 않음)하려는 경우
- 스레드에 직접 이름을 붙여서 오류 발생시 덤프파일 및 직접 작성한 로그 파일에서 스레드 이름이 표시되도록 하고자 하는 경우

<br>

## 커스텀 ThreadFactory

`ThreadFactory` 를 implements 해서 커스텀 ThreadFactory 를 구현해 사용할 수 있다. 아래는 그 예제다.

```java
public class MyThreadFactory implements ThreadFactory{
    private final String poolName;
    
    public MyThreadFactory(String poolName){
        this.poolName = poolName;
    }
    
    public Thread newThread(Runnable runnable){
        return new MyThread(runnable, poolName);
    }
}
```

이렇게 `ThreadFactory` 를 implements 한 커스텀 `ThredFactory` 를 사용하면, 스레드 풀의 이름을 인자로 넘겨서 스레드 덤프 파일이나 로그 파일에서 특정 스레드가 어떤 스레드 풀에 속하는지 확인할 수 있도록 할 수 있다.<br>

스레드 덤프 파일이나 로그파일에 의미없는 스레드 일련번호 대신 스레드의 이름이 직접 출력되기 때문에 디버깅할 때 매우 요긴하게 쓰일 수 있다. <br>

<br>

## 커스텀 Thread 

Thread 클래스를 상속한 커스텀한 Thread 클래스를 생성할 수 있다. 물론 상위 호출단에서는 가급적 구체타입이 아닌 상위타입인 `Thread` 타입으로 인식되게 해서 호환이 가능하도록 해두어야 한다.<br>

<br>

아래는 그 예제다.

```java
public class MyAppThread extends Thread{
    public static final String DEFAULT_NAME = "MyAppThread";
    private static volatile boolean debugLifecycle = false;
    private static final AtomicInteger created = new AtomicInteger();
    private static final AtomicInteger alive = new AtomicInteger();
    private static final Logger log = Logger.getAnonymousLogger();
    
    public MyAppThread(Runnable r){
        this(r, DEFAULT_NAME);
    }
    
    public MyAppThread(Runnable r, String name){
        super(Runnable, name + "-" + created.incrementAndGet());
        
        setUncaughtExceptionHandler(
            new Thread.UncaughtExceptionHandler() {
                public void uncaughtException(Thread t, Throwable e){
                    log.level(
                        Level.SEVERE, 
                        "UNCAUGHT in thread " + t.getName(), 
                        e
                    )
                }
            });
        
    }
    
    public void run(){
        // debug 플래그를 복사해 계속해서 동일한 값을 갖도록 한다.
        boolean debug = debugLifeCycle;
        
        if(debug) log.log(Level.FINE, "Created " + getName());
        
        try{
            alive.incrementAndGet();
            super.run();
        }
        finally{
            alive.decremeentAndGet();
            if(debug) log.log(Level.FINE, "Exiting " + getName());
        }
    }
    
    public static int getThreadsCreated(){
        return created.get();
    }
    
    public static int getThreadsAlive(){
        return alive.get();
    }
    
    public static boolean getDebug(){
        return debugLifecycle;
    }
    
    public static void setDebug(boolean b){
        debugLifeCycle = b;
    }
}
```

위의 커스텀 `Thread` 클래스에는 아래의 기능들이 포함되어 있다.

- 스레드의 이름을 지정하는 것을 포함해 에러가 발생하면 해당 에러를 Logger 클래스를 통해 로그로 남겨주는 `UncaughtExceptionHandler`  
- 스레드가 몇개나 생성되고 제거됐는지에 대한 간단한 통계 값
- 스레드가 생성되고 종료될 때 디버깅용 메시지를 출력하는 기능

<br>

## previliegedThreadFactory 팩토리 메서드

애플리케이션에서 보안 정책(security policy)를 사용해 각 부분마다 권한을 따로 지정하고 있다면 `Executors` 에 포함되어 있는 `previliegedThreadFactory` 팩토리 메서드를 활용한 스레드 팩토리 메서드를 만들어 사용하는 것을 검토해볼 수 있다. 자세한 내용은 스킵해야 할 것 같다. 양심상 정리하는 게 맞겠지만 최근에 시간이 부족해서 일단은 스킵해야할 것 같다. 2회독 시에 이곳을 다시 정리하게 되지 않을까 싶다.<br>

<br>























