# 8.3.2 큐에 쌓인 작업 관리

작업을 처리할 수 있는 능력보다 많은 양의 요청이 들어오면 처리하지 못한 요청은 큐에 계속해서 쌓인다. 스레드 풀을 사용하는 경우 Executor 클래스에서 관리하는 큐에 Runnable 로 정의된 작업이 계속해서 쌓인다. 

즉, 스레드 풀에 있는 모든 작업이 실행중일때 작업이 등록되면, 스레드 풀 대신 작업은 큐에 쌓이게 된다.

스레드 풀을 사용할 때에 스레드 풀을 사용하지 않는 경우에 비해 문제가 덜 발생하기는 하지만, 스레드 풀을 사용할 경우는, 큐가 꽉 찼을때의 해결방안이 필요하다.

> **참고 : 스레드 풀 없이 스레드가 계속해서 생성되는 경우**<br>
>
> 6 장에서는 스레드 풀 없이 스레드가 계속해서 생성되는 경우 생성되는 스레드마다 CPU를 확보하기 위해 대기한다는 것을 알아봤었다. 

책에서는 대기중인 작업을 `Runnable`로 표현하고, `List` 형태로 `Runnable` 을 관리하는 것을 스레드 풀을 사용하는 경우로 비유를 했는데, 이 경우 애플리케이션이 처리할 수 있는 것보다 많은 양의 자원이 들어올 때 메모리라는 시스템 자원 역시도 결국은 모자라게 된다.

<br>

대량의 트래픽이 갑자기 몰리는 경우는 스레드 풀가 작업 큐를 사용해 충분히 유연하게 처리할 수 있다. 하지만 대량의 트래픽이 계속해서 같은 속도로 추가되면, 속도 조절 기능을 사용하거나, 큐에 대한 작업 관리 전략을 적용해야 한다.<br>

속도 조절기능은 클라이언트 측에서 속도를 느리게 조절하는 방식인데, 실생활에서는 거의 사용되지 않는 방식이다.<br>

큐에 대한 작업관리 전략은 세가지가 있다. <br>

1 ) 큐에 크기 제한을 두지 않는 방법 <br>

2 ) 큐의 크기를 제한하는 방법 <br>

3 ) 작업을 스레드에게 직접 넘겨주는 방법 <br>

<br>

## 크기가 제한되지 않은 큐

`newFixedThreadPool` 메서드, `newSingleThreadExecutor` 메서드에서 생성하는 스레드 풀은 기본 설정으로 크기가 제한되지 않은 LinkedBlockingQueue를 사용한다. 

스레드 풀에 있는 모든 작업이 실행중일때 작업이 등록되면, 스레드 풀 대신 작업은 큐에 쌓이게 된다. 이때 작업이 처리되는 속도보다 작업이 추가되는 속도가 더 빠르면 큐에 끝없이 계속해서 작업이 쌓일 수 있다.<br>

스레드의 갯수가 굉장히 많거나 제한이 거의 없는 상태일 경우 작업을 큐에 쌓는 절차를 생략할 수 있다. 이럴 때는 `SynchronousQueue` 를 사용해서 프로듀서에서 생성한 작업을 컨슈머인 스레드에게 전달할 수 있다. `SynchronousQueue`는 스레드간에 작업을 넘겨주는 기능을 담당한다.<br>

아래에서부터는 점심시간 이후에 정리해두어야 할 것 같다. 어제 코로나 검사를 받아야 해서 두시간 넘게 찬바람 맞으면서 무거운 가방 메고 서 있었더니 몸 상태가 축 쳐져서 집중이 잘 안된다. 더강남 앱을 켜서 진단결과 보니 음성이라고 나와서 다행이긴 하지만, 왜이리 피곤한지 휴... 조금만 후퇴했다가 2보 전진해야겠다...

`SynchronousQueue`에 작업을 추가하려면 컨슈머인 스레드가 이미 작업을 받기 위해 대기하고 있어야 한다. 대기 중인 스레드가 없는 상태에서 스레드의 갯수가 `maximumPoolSize` 보다 적을 경우 `ThreadPoolExecutor` 를 활용해 새로운 스레드를 생성해 동작시킨다.<br>

최대 크기(`maximumPoolSize`) 보다 작으면 `ThreadPoolExecutor` 는 새로운 스레드를 생성해 동작시킨다.