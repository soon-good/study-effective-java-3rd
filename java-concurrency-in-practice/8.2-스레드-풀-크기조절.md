# 8.2 스레드 풀 크기 조절

> 책의 내용은 다소 장황하다. 정리하고 보니 짧아져서 읽기 편해졌다.

<br>

스레드 풀의 크기를 하드코딩해서 고정시키는 것은 좋은 방법이 아니다. 스레드 풀의 크기는 가급적 설정 파일 또는 Runtime.availableProcessors() 와 같은 메서드로 동적으로 지정이 가능하도록 해야한다.<br>

<br>

**스레드 풀의 크기를 너무 크게 설정했을 경우**

- 스레드는 CPU나 메모리 등의 자원을 조금이라도 더 확보하기 위해 경쟁하게 된다.
- 이때 CPU에 부하가 걸리고 메모리는 모자라게 되어 금방 자원 부족에 시달리게 된다.

<br>

**스레드 풀의 크기를 너무 작게 설정했을 경우**

- 작업량은 계속 쌓이지만, CPU나 메모리는 남아돌아서 작업 처리 속도가 떨어지게 된다.

스레드 풀의 크기를 적절하게 산정하려면 cpu 갯수는 몇개인지, 메모리는 어느 정도 되는지, 작업이 CPU를 많이 사용하는 작업인지 아니면 IO작업을 많이 사용하는지 등을 미리 알고 있다면 스레드 풀의 크기를 정하는 데에 도움이 된다. 

처리할 작업의 종류가 다양하면, 작업의 부하에 따라 섬세하게 성능을 조절할 수 있도록 여러 개의 스레드 풀을 만들어 활용하는 방법도 고려해볼만 하다.

<br>

**CPU 를 많이 사용하는 작업**

N개의 CPU가 있는 컴퓨터에서 스레드 풀을 사용해 작업을 한다고 하자. 이때 스레드의 갯수를 N+1 개로 맞추면 효율적이다. CPU를 온전히 사용하는 작업이기에 스레드 하나 당 CPU 하나를 부여하는 것이다. 나머지 +1 로 부여하는 것은 페이징 오류가 발생하거나 기타 요인으로 인해 스레드가 멈추는 경우가 있어서 1개의 추가 스레드를 미리 마련해 두면 스레드 중 하나에 장애가 발생하면 다음 스레드를 꺼내서 작업을 할 수 있다. 즉, 노는 CPU 없이 모든 CPU를 일하게끔 할 수 있는 것이기에 CPU를 효율적으로 이용하는 결과를 낼 수 있다.

<br>

**I/O 작업이 많은 작업 / 블로킹 및 딜레이가 있는 작업을 해야 하는 경우**

I/O 작업은 작업을 요청하는 데에는 시간이 얼마 걸리지 않는다. 하지만 원격지에 데이터를 요청해서 기다리는 PENDING 상태가 있다. 이 요청을 기다리는 시간이 컴퓨터에게는 어마어마한 시간이다. 컴퓨터 공학과를 재학했든, 비전공자이지만 실무를 접하면서든 누구든 한번씩 들어봤을 이야기다. I/O 작업의 특성은 CPU를 이용한 연산작업은 얼마 되지는 않지만 다수의 네트워크 딜레이를 유발시키는 경우가 많다. 이 경우 모든 스레드가 대기 상태에 들어가 전체적인 진행이 멈출 수 있기 때문에 스레드 풀의 크기를 훨씬 크게 잡아야 할 필요가 있다.

<br>

**I/O 작업도 큰데, CPU 작업도 큰 경우**

잘은 모르지만, 머신러닝을 하는 경우를 예로 들 수도 있겠다. 이 경우 데이터베이스에서 데이터를 가져오는 경우가 IO에 소모되는 시간으로 산정할 수 있다. 어떻게든 IO 시간을 줄이려면 레디스를 사용한 인메모리 캐시를 적절히 잘 사용하거나, 하둡 등의 시스템을 구축해 검색속도를 빠르게 할 수 있는 대책을 마련할 수도 있을 것 같다. 

<br>

**스레드 풀의 크기를 적당하게 정하려면... 실제 작업시간 대비 대기시간의 비율을 구해봐야 한다.**

스레드 풀의 크기를 적당하게 정하려면 처리해야 할 작업이 시작에서부터 종료시까지 **실제작업시간 대비 대기시간의 비율**을 구해봐야 한다.

작업시간 1초당 대기시간이 어느 정도인지 구하듯 작업시간 1개당 대기시간은 어느정도인지 비율을 계산한다.

이때 이 비율이 꼭 정확해야 하고 정해진 지표를 구해서 하는 것은 아니다. 몇 가지 성능 측정 툴을 사용하거나 기타 단순한 방법으로 비율을 구해볼 수도 있다.

또는 개발용도의 환경에서 스레드 풀의 크기를 직접 조절해가면서 실행하면서 애플리케이션의 스레드 풀의 크기가 어느 수준일 때 CPU가 가장 열심히 일을 하는지 알아보는 것도 좋은 방법이다.

어떻게든 본인이 처한 환경에서 효율적인 방식이거나 직관적인 방식으로 측정하면 된다.

<br>

**스레드 풀 크기 예측 공식**

이 공식은 정해진 공식은 아니지만 기타 다른 책들에서 이 공식이 자주 언급되는 편이다.

- Ncpu - CPU 갯수

	- Runtime.getRuntime().availableProcessors() 로 구할 수 있다.

- Ucpu - CPU 활용도(usage). Ucpu 값은 0 ~ 1 사이의 값이다.

	- ex) 4core 중에서 3코어를 쓸것이라고 가정한다면 3/4 = 0.75다. 이것을 버림으로 계산해서 0.7로 산정할 수 있다.

- W/C - 대기시간(Wait)/작업시간(Cost)

	- 작업시간 대비 대기시간
  	- 작업시간 1초당 대기시간이 어느 정도인지 구하듯 작업시간 1개당 대기시간은 어느정도인지 비율을 계산
  	- 대기 시간이 더 클수도 있다.(IO 작업이 더 크다면)
  	- 작업시간이 더 클 수도 있다.(CPU 연산이 크다면)

위의 값들을 활용하면 아래의 수식으로 스레드 풀의 크길를 구할 수 있다. 절대적으로 항상 맞는 것은 아니지만, 시도해봄직하다.

- Nthread(스레드갯수) = Ncpu x Ucpu x (1 + W/C)

<br>

**CPU 사용량 조절 외의 여러가지 용도의 스레드 풀**<br>

스레드 풀은 CPU 사용량을 조절하는 데에만 사용하지 않는다. 스레드 풀을 사용하면 메모리, 파일핸들, 소켓핸들, 데이터베이스 같은 자원(리소스)의 사용량도 조절하는 것이 가능하다. 오히려 CPU 하나에 대한 스레드 풀의 크기를 정하는 것보다 쉬운 편이다.<br>

각 작업에 대해 필요한 자원의 양을 모두 더한 값을 자원의 전체 갯수로 나눠주면 된다. 이 값이 스레드 풀의 최대 크기에 해당한다. (자원의 전체 갯수라는 것은 실제 물리적인 하드웨어의 갯수를 의미한다.)<br>

각 작업 하나 당 데이터베이스 연결 하나를 사용하는 경우를 생각해보자. 이 경우 스레드 풀의 실제 크기는 데이터베이스 connection pool 의 크기로 제한된다고 볼 수 있다.<br>

반면, 특정 스레드 풀에서만 DB Connection pool 을 사용한다고 가정하면 데이터 베이스 커넥션 풀 내부의 커넥션 풀 내부의 커넥션 들 중에서 실제로 스레드 풀의 크기 만큼만 커넥션들이 사용된다.<br>

<br>

이번 문서 다음에 정리할 내용은 8.3 절인데, 굉장히 중요한 내용이 많다...