# ITEM 6. 불필요한 객체 생성을 피하라

> 아이템 17, 아이템 1

<br>

- 기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라.
- 참고) 
  - 아이템 50) 새로운 객체를 만들어야 한다면 기존 객체를 재사용하지 마라.
  - 아이템 50 과 "기존 객체를 재사용해야 한다면 새로운 객체를 만들지 마라"와는 조금은 다른 이야기.

<br>

불필요한 객체가 생성되는 예<br>

- 불변객체는 언제든 재사용할 수 있다.
  - ex) String s = new String ("bkikini"); // no!!!
  - String s = "bikini"; // 새로운 인스탄스를 매번 만드는 대신 하나의 String 인스턴스를 사용한다. 같은 가상머신 안에서 이와 같은 문자열을 사용하는 모든 코드가 같은 객체를 재사용하는 것을 보장하게 된다. (JLS, 3.10.5)
- 정적팩터리가 아닌 생성자를 사용하는 경우 (아이템 1)
  - 자주사용되고, 유틸리티 성격의 클래스는 정적 팩터리 상태가 낫다.
  - 생성자는 호출할 때마다 새로운 객체를 만들지만 팩터리 메서드는 전혀 그렇지 않다. 불변객체 만이 아니라 가변객체라 해도 사용중에 변경되지 않을 것임을 안다면 재사용할 수 있다.
  - ex) Boolean(String) 을 사용하는 경우
  - => 이 경우 Boolean.valueOf(String)을 사용하는 것이 권장된다.
- 생성 비용이 비싼 객체
  - ex) String.matches
  - 성능이 중요한 상황에서 반복문 내에서 사용하기에는 적합하지 않다.
- 어댑터 패턴
  - ex) Map 인터페이스의 keySet 메서드
  - 객체가 불변이라면 재사용해도 안전함이 명백하다. 하지만 덜 명확하거나, 직관에 반대되는 경우도 있는데, 어댑터 패턴을 사용하는 경우를 예로 들 수 있다.
  - 어댑터 패턴은 흔히 뷰(View)라고도 한다.
- 오토박싱
  - 오토박싱은 기본 타입과 박싱된 기본 타입의 구분을 흐려주지만, 완전히 없애주는 것은 아니다. 
  - 아이템 61
  - 기본 자료형과 참조자료형을 사용했을 때의 의미는 같을 수 있지만 오토박싱이 for 문에서 발생할 때, for 문으로 순회해야 하는 양이 많을 경우 성능상으로 느려질 여지가 있다.





> 참고: 어댑터 패턴<br>
>
> 실제 작업은 뒷단 객체에 위임하고, 자신은 제 2의 인터페이스 역할을 해주는 객체다. <br>
>
> 어댑터는 뒷단 객체만 관리하면 된다. 즉, 뒷단 객체 외에는 관리할 상태가 없기 때문에 뒷단 객체 하나당 어댑터 하나씩만 만들어지면 충분하다.<br>

<br>

