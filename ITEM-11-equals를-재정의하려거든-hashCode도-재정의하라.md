# ITEM 11. equals를 재정의하려거든 hashCode도 재정의하라

> 해시를 사용하는 컬렉션 내에서 논리적으로 객체가 같음을 보장하기 위해서는 hashCode() 를 잘 작성해야 한다. <br>
>
> 해시 자료구조는 중요하다고 판단되는 편인 것 같다. 해시의 중요성?에 대해서는 아래 자료를 참고하면 좋을 듯 하다.<br>
>
> [포프 tv - Hash Table 은 프로그래머의 기본기](https://www.youtube.com/watch?v=S7vni1hdsZE)<br>
>
> ![이미지](https://i.ytimg.com/vi/S7vni1hdsZE/hqdefault.jpg)<br>
>
> <br>
>
> 문자열을 해싱하는 것에 대해서는 자세히 나오지 않아서, 한달이 걸리더라도 직접 이것 저것 자료를 찾아보고 정리를 해두지 않을까 싶다. 

<br>

Chapter2 의 ITEM 들은 대부분 매우 길고, 산만하다. 지금 정리하는 아이템 11도 그렇다. 아이템 10의 경우는 굉장히 긴데, 정리하는데 꽤 시간이 걸릴 것 같다.<br>

<br>

## 참고자료

- Effective Java 3/E
- jbloch
- [포프 tv - Hash Table 은 프로그래머의 기본기](https://www.youtube.com/watch?v=S7vni1hdsZE)

<br>

## equals 를 재정의한 클래스에서는 반드시 hashCode 도 재정의해야 한다.

hashCode 를 재정의하지 않으면 hashCode 일반 규약을 어기게 된다. 만약 내가 만들려는 클래스에서 equals 메서드를 재정의해서, 동치관계 검사를 수정했다고 해보자. 이 경우, hashCode 메서드도 수정해주어야 한다. 그래야 HashMap, HashSet 과 같은 컬렉션에서 컬렉션 내의 원소로 사용할 때 문제를 일으키지 않는다.<br>

<br>

## 참고) Object 명세 내의 equals 관련 규약<br>

 - hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.
   - equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 같은 객체에 대한 hashCode는 몇번을 호출해도 같은 값을 반환해야 한다. 
 - equals(Object) 가 두 객체를 같다고 판단하면, 두 객체의 hashcode 는 똑같은 값을 반환해야 한다.
 - equals(Object) 가 두 객체를 다르다고 판단했어도, 두 객체의 hashCode가 서로 다른 값을 값을 반환할 필요는 없다.
   - 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.
   - 즉, 다른 객체에 대해 hashCode 가 항상 유일해야 하는 것은 필수는 아니지만, 항상 유일하게끔 hashCode를 구현하면, 해시테이블의 성능이 좋아진다.

<br>

## equals(Object) 로 두 객체가 같다고 판정되면 hashCode() 도 같은 값을 반환해 두 객체가 같음을 보장해야 한다

Object 명세 내의 두번째 조항인 **"equals(Object) 가 두 객체를 같다고 판단하면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다"**는, hashCode를 잘못 재정의 했을때 크게 문제가 되는 조항이다. 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다. 왜냐하면, hashMap, hashSet과 같은 컬렉션 내에 객체를 키로 사용하는 경우에 모호함이 발생하기 때문이다. <br>

> 참고) <br>
>
> **물리적으로 다른 객체**<br>
>
> 메모리 주소가 다른 객체를 말한다. 예를 들면, 아래의 코드에서 a, b 는 물리적으로 다른 객체다. 
>
>  ```java
>  Student a = new Student(); 
>  Studuent b = new Student();
>  ```
>
> **논리적으로 같은 객체**<br>
>
> 특정 필수 필드가 같을 경우 같은 존재로 인식해야 할 때 사용한다. 아래 코드에서 a, b 는 물리적으로는 다른 객체이지만, 논리적으로는 같은 객체다. 논리적으로 같은 객체로 판정되게끔 하려면 동치가 성립되게끔 equals() 를 구현해야 한다. 여기서 더 나아가서 hashCode() 까지 같도록 hashCode()를 구현해놓으면, hash 를 사용하는 자료구조에서도 동치 여부를 판단할 수 있게 된다.
>
> ```java
> Student a = new Student("021225-1057777", "베트맨");
> Student b = new Student("021225-1057777", "베트맨");
> ```

<br>

Object 의 hashCode를 그대로 사용하는 객체 PhoneNumber p1 이 있다고 해보자. 그리고 PhoneNumber 객체에는 equals 규약을 지켜서 equals 메서드가 정의되어 있다. 이 경우 p1 과 완전히 같은 값을 복사한 PhoneNumber p2 가 있다고 해보자. 이때 p1.equals(p2)는 성립한다. <br>

**Object 의 hashCode()**<br>

Object 의 hashCode() 는 생성된 물리적인 객체에 대한 해시코드다. 논리적인 값들에 대해 걸어놓은 해시코드가 아니다.

하지만 p1.hashCode() 와 p2.hashCode() 값은 서로 다르다. Object의 hashCode를 재정의 하지 않고 그냥 사용했기 때문인데. Object의 hashCode는 생성된 물리적인 객체에 대한 해시코드 문자열을 만들어내기 때문에 PhoneNumber 클래스에 hashCode()메서드를 재정의하지 않으면 p1, p2 의 hashCode()는 다를 수 밖에 없다.<br>

아래의 예제코드를 보자. (단, PhoneNumber 클래스는 hashCode() 메서드를 재정의하지 않은 상태임을 가정한다.)

```java
Map<PhoneNumber, String> m = new HashMap<>();
m.put(new PhoneNumber(707, 867, 5309), "제니");
```

이 코드 다음에 논리적으로 같은 값이 주입된 m.get(new PhoneNumber(707, 867, 5309)) 를 실행하면 "제니"가 나와야 할 것 같지만, 실제로는 null 을 반환한다. hashCode() 를 재정의하지 않아서 Object 의 hashCode() 메서드가 사용되었기 때문이다.<br>

이렇게 되면 get메서드가 엉뚱한 해시버킷에 가서 객체를 찾으려 하게 된다. 또는 두 인스턴스를 같은 버킷에 담게 되더라도 get 메서드는 여전히 null 을 반환하게 된다. HashMap 은 해시코드가 다른 엔트리끼리는 동치성 비교를 시도조차 하지 않도록 최적화되어 있기 때문이다.<br>

이렇게 해시를 사용하는 컬렉션 내에서 논리적으로 객체가 같음을 보장하기 위해서는 hashCode() 를 잘 작성해야 한다. 이 hashCode() 를 작성하는 올바른 원칙과 hashCode() 를 잘못 사용하는 예에 대해서 아래에서 설명하고 있다.<br>

<br>

## hashCode() 를 잘못 사용하는 예

아래 코드는 동치인 모든 객체에서 똑같은 해시코드를 반환하게 되기 때문에 언뜻 보기에는 적법해보인다. 하지만, 모든 객체에게 항상 같은 값을 내어주게 된다. 따라서 모든 객체가 해시 테이블의 버킷 하나에 담겨 마치 연결리스트(linked list)처럼 동작하게 된다. <br>

그 결과, 평균 수행 시간이 O(1)인 해시 테이블이 O(n)으로 느려져서, 객체가 많아지면 도저히 쓸 수 없게 된다.

```java
@Override
public int hashCode(){
  return 42;
}
```

<br>

## hashCode를 작성하는 올바른 요령

좋은 해시함수는 서로 다른 인스턴스에 대해 다른 해시코드를 반환한다. 이 원칙은 hashCode의 세 번째 규약이 요구하는 속성이다. 이상적인 해시 함수는 주어진 서로 다른 인스턴스 들을 32비트 정수 범위에 균일하게 분배해야 한다. (언뜻 어려워보이기는 하지만, 그리 어렵지는 않다.)<br>

<br>

**hashCode 를 작성하는 간단한 요령**

- 파생 필드는 해시 코드 계산에서 제외해도 된다.
  - 파생 필드는 다른 필드로부터 계산해낼 수 있는 필드를 의미하느데, hashCode 계산에서 파생필드와 관련된 필드는 모두 무시해도 된다.

- Equals 비교에 사용되지 않은 필드는 반드시 제외한다.
  - equals 비교에 사용되지 않은 필드르 사용하는 것은 hashCode 규약 두번째를 어기게 될 위험이 있다.
  - hashCode 두번째 규약은 아래와 같다.
    -  "equals(Object) 가 두 객체를 같다고 판단하면, 두 객체의 hashcode 는 똑같은 값을 반환해야 한다.



**hashCode 를 만드는 절차**<br>

- 1 . int 변수 result 를 선언한 후 값 c 로 초기화한다. 
  - 이때 c 는 해당 객체의 첫 번째 핵심 필드를 단계 2.a 방식으로 계산한 해시코드다. (여기서 핵심 필드란 equals 비교에 사용되는 필드를 말한다.)
- 2 . 해당 객체의 나머지 핵심 필드 f 각각에 대해 아래의 작업을 수행한다.
  - `b` .  2.a 의 1), 2) 3) 의 방식으로 계산한 해시코드 c 를 int 타입 result 에 초기화(갱신)한다.
    - `result = 31 * result + c;` 
  - `a` . 해당 필드의 해시코드 c를 계산한다.
    - 1 ) primitive type 일 경우
      - Type.hashCode(f) 를 수행한다. 예를 들면 [Integer.hashCode()](https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#hashCode()) 를 예로 들수 있다.
    - 2 ) 참조 타입 필드일 경우
      - 이 클래스의 equals 메서드가 이 필드의 equals() 를 재귀적으로 호출해 비교한다면 이 필드의 hashCode를 재귀적으로 후출한다. (잉?)
      - 계산이 더 복잡해질 것 같으면, 이 필드의 표준형(canonical representation)을 만들어 그 표준형의 hashCode를 호출한다.
      - 필드의 값이 null 이면 0 을 사용한다.
      - 다른 상수도 괜찮지만 전통적으로 0을 사용한다.
    - 3 ) 필드가 배열일 경우
      - 핵심 원소 각각을 별도 필드처럼 다룬다.
- 3 . result 를 반환한다.

<br>

**hashCode 검증**<br>

hashCode 를 다 구현했다면, 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환하는지 검증 역시도 거쳐야 한다. (equals와 hashCode 를 AutoValue로 생성했다면 건너뛰어도 좋다)<br>

<br>

**31*result**<br>

**곱셈을 해시코드 생성에 사용한 이유**<br>

곱셈을 하는 것은 필드를 곱하는 순서에 따라 result 값이 달라지게끔 해준다. 이렇게 곱셈을 사용하면 클래스에 비슷한 필드가 여러개 있을 때 해시 효과를 크게 높여준다. 만약 예를 들면, String 의 hashCode 를 곱셈 없이 구현한다면 모든 아나그램의 해시코드가 같아지게 된다.<br>

<br>

**소수를 해시코드 생성에 사용한 이유**<br>

해시코드 생성에 31*result 를 사용했었는데, 이때 곱할 숫자로 31을 선택했다. 31은 소수(prime)이면서 홀수다. 곱할 숫자를 선정할 때 홀수이면서 소수인 숫자를 선택하는 편이다. 

- 홀수를 선택해 곱하는 이유
  - 짝수를 선택하는 경우 오버플로가 발생할 때 정보를 잃게 된다. 
  - 2를 곱하는 것은 시프트연산과 같은 결과를 내기 때문이다.
- 소수를 선택해 곱하는 이유
  - 명확하지는 않지만 전통적으로 그리해왔다.

<br>

**곱셈 연산을 시프트&뺄셈 연산으로 최적화하기**<br>

결과적으로 31을 result에 곱하고 나면, 이 곱셈을 시프트 연산과 뺄셈으로 대체해 최적화할 수 있다.<br>

(참고. 요즘 VM들은 이런 최적화를 자동으로 해주고 있다.)<br>

ex)

> 31 * i = (i<<5) - i

<br>

## PhoneNumber 클래스에 hashCode() 적용해보기

PhoneNumber 클래스의 hashCode() 메서드는 PhoneNumber 인스턴스의 핵심필드 3개만을 이용해 간단한 계산만 수행한다. 그 과정에서 비 결정적(undeterministic) 요소는 전혀 없기에 동치인 PhoneNumber 인스턴스들은 같은 해시코드를 가지게 된다. 

> 참고) 비결정적인 요소<br>
>
> 외부에서 전달받는 값에 의해 변하는 값. 예를 들면 DB에서 가져오는 값은 다른 코드에서 해당 행을 수정하는 경우도 있을 수 있다. 또는 hashCode() 에 현재 시간의 날짜 + 시/분/초 로 timestamp 를 사용하는 경우도 어찌보면 비 결정적인 요소다. 이렇게 외부에 의해 변경되는 값들은 비결정적인 요소다. <br>
>
> 아래의 코드는 비결정적인 요소가 없다. 물론 실생활에서 전화번호는 변경될수 있는 요소다. 하지만, 전화번호 하나가 특정 사람에 매칭된 것이 아닌, 전화번호 하나에 대해서만 고유성을 가진 객체가 되게끔 클래스의 필드들을 만들어 두었다. 따라서 비결정적인 코드가 아니다.

<br>

```java
@Override
public int hashCode(){
  int result = Short.hashCode(areaCode);
  result = 31 * result * Short.hashCode(prefix);
  result = 31 * result + Short.hashcode(lineNum);
  return result;
}
```

<br>

## 해싱 라이브러리들

위에서 설명한 해시 함수 제작 요령은 최첨단 방식은 아니다. 되도록 쉬운 코드를 통해 개념을 설명하기 위해 제시된 예제다. 해시 충돌이 적은 방법을 꼭 써야 한다면 아래의 라이브러리들을 사용하는 것도 하나의 방법이 될 것 같다.

- AutoValue (아이템 10)
- 구아바 
  - com.google.common.hash.Hashing
- [murmur3](https://mvnrepository.com/artifact/com.github.eprst/murmur3)
- Objects 클래스
  - Objects 클래스는 임의의 갯수만큼 객체를 받아 해시코드를 계산해주는 정적 메서드인 hash 를 제공한다.
  - 하지만 아쉽게도 속도는 조금 느리다. 입력 인수를 담기 위한 배열이 만들어지고, 입력 중 기본 타입이 있다면 박싱과 언박싱도 거쳐야 하기 때문이다. 따라서 hash 메서드는 성능에 민감하지 않은 상황에서만 사용해야 한다.
- 

<br>

## 해시코드 캐싱

> 참고) 캐싱이라고 해서 캐시를 사용하겠다는 의미는 아니다. 책의 저자분 께서는 객체의 초기화가 되지 않았을 경우 지연초기화를 해두어 하나의 필드에 저장해두는 방식을 나름 캐싱이라는 용어로 설명하고 있다. 캐싱이라는 단어 말고 이것을 설명할 단어가 따로 없기는 하다.

클래스가 불변이고 해시코드를 계산하는 비용이 크다면 매번 새로 계산하기 보다는 캐싱하는 방식을 고려해야 한다. 이 타입의 객체가 주로 해시의 키로 사용될 것 같다면 인스턴스가 만들어질 때 해시코드를 계산해둬야 한다. 해시코드의 키로 사용되지 않는ㄴ 경우라면 hashCode가 처음 불릴 때 계산하는 지연 초기화(lazy initialization) 전략을 고려해보는 것도 좋다.<br>

필드를 지연 초기화하려면 그 클래스를 스레드 안전하게 만들도록 신경써야 한다.(아이템 83)<br>

PhoneNumber 에 지연 초기화까지 적용할 필요까지는 없지만 예시를 위해 한번 확인해보면 아래와 같다.<br>

```java
private int hashCode;

@Override 
public int hashCode(){
  int result = hashCode;
  if(result == 0){
    result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    hashCode = result;
  }
  return result;
}
```



## hashCode 사용시 주의사항

**성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안된다.**<br>

속도가 빨라지겠지만 해시 품질이 나빠져서 해시 테이블의 성능을 심각하게 떨어뜨릴 수 있다.<br>

특히 어떤 필드는 특정 영역에 몰린 인스턴스 들의 해시 코드를 넓은 범위로 고르게 퍼뜨려 주는 효과도 있을지 모른다.<br>

이렇게 하면 O(1) 급의 해시코드 성능이 O(n)에 가깝게 수렴해 해시 테이블의 속도가 선형으로 느려질 수 있다.<br>

<br>

> **Java 2 의 String. 해시코드를 잘못 사용한 예**<br>
>
> 자바 2 전의 String 은 최대 16개의 문자만으로 해시코드를 계산했다. 문자열이 길면 균일하게 나눠서 16문자만 뽑아서 해시코드를 생성했었다. 이렇게 되면 중복되는 해시코드가 많아지게 되어 해싱 성능이 안좋아지게 된다.<br>
>
> 만약 URL 처럼 계층적인 이름을 대량으로 사용한다면 이런 해시 함수는 앞서 이야기한 심각한 문제를 고스란히 드러낸다.

<br>

**hashCode 의 생성 규칙을 API 사용자에게 자세하게 명시하지 말 것.**<br>

이렇게 해야 클라이언트가 이 값에 의존하지 않고, 추후에 계산 방식을 바꿀 수 있다.

> String, Integer
>
> 자바 라이브러리의 많은 클래스에서 hashCode 메서드가 반환하는 정확한 값을 알려주고 있다. 바람직하지 않은 점이다. 자세한 규칙을 공표하지 않았다면, 다음 릴리즈에서 더 나은 해시 방식을 구현해서 수정배포할 수 있다는 점이 있기에 API에 hashCode 의 생성 규칙을 명시하지 않는 것이 권장된다.

<br>

## 핵심정리

equals 를 재정의할 때는 hashCode 도 재정의해야 한다. <br>

재정의한 hashCode는 Object 의 API 문서에 기술된 일반 규약을 따라야 하고, 서로 다른 인스턴스라면 되도록 해시코드도 다르게 되도록 구현해야 한다. <br>

그런데, hashCode 를 너무 자주 구현해야 할 경우 조금은 부담으로 다가올수 있는데, 잘 알려진 프레임워크인 AutoValue 프레임워크(아이템 10)를 사용하면 equals와 hashCode를 자동으로 만들어준다. 이 외에도 murmur3, 구아바, Objects 와 같은 라이브러리를 사용하면 hash를 만들어내는데에 도움을 얻을 수 있다.<br>

<br>
